HW4 Due 11:59PM November 15

***There will be no reviews for this Homework***

Please write your answer in this file.

1. What did you essentially learn in this course about design?
                                
Please provide individual responses to this question here (state your name and write in short paragraphs below that).

Ibrahim:
Most people underestimate the importance of software design and some don't know what it is and its benefits. Unfortunately, I was one of them before I took this course but not anymore. I learnt that software design is a solid foundation in a software development life cycle, which encompasses quality, maintainability, adaptability, and reliability. One of the main reasons why a good software design is so important is the requirements of the software always change. To fight this problem, the software must be extensible - that incorporating new features is as easy as adding new components to the abstraction. I learnt that extensibility comes from modularity, which is dividing software into components and building each module once. Building modular code with high cohesion and low coupling ensures that it is easy to reuse, easy to test and debug. Following the design principles SRP, OCP, DIP, YAGNI, DRY, and LSP makes the software even more flexible to changes and fault-tolerant. 
	Moreover, I learned automated testing with continuous integration ensures a consistent build process, mitigates risk, and inspires confidence. Especially, the ability to mock in unit testing isolates and focuses on code being tested rather than behavior or state of external dependencies. Also, the concept of test first with refactoring in Test Driven Development taught me how to deliver a better quality code without violating the design principles. TDD makes sure that each functionality added is really needed and that helps to build the evolutionary design.
	Also, in the process of learning, I leant to let the design evolve and fall into well-proven design patterns that define the system architecture. I agree that although design patterns won't guarantee an absolute solution to a problem, they make the overall system easier to read, understand and maintain. Particularly, design patterns make the communication easier between designers and developers.

Joseph:
The main thing I learned this semester in software design is that you should design and develop software knowing that your code WILL change. Software engineers do not have the luxury of a fixed design as is common in other engineering disciplines (I remember you dislike connecting the term "engineering" to software.) All other principles and techniques follow cleanly from this premise. OCP, DRY, YAGNI, SRP, and DIP can all be tied to the inevitable evolution and ever-changing nature of software.
	This idea of ever-changing code leads directly to the idea of evolutionary design. I learned that we want to code in the middle ground between Big Up-Front Design and Just In Time Design. There’s time for thinking up front as long as it doesn’t hinder us. A major lesson that enables evolutionary design is automated testing. Automated testing allows you the freedom to make changes quickly, which in turn allows you to evolve the design as necessary without fear of breaking your code. Automated testing doesn't slow you down - it allows you to go faster with more confidence in the results. Within automated testing, I specifically learned how to unit test and mock. Mocking is a skill that seems to allow much greater testing abilities and control. It allows you to feel much more confident in having to rely on external dependencies. Unit testing in general allows you to design robust code that rarely fails or fails gracefully.
	Also, over the course, I grew a large appreciation for rethinking about code again and again. This essentially forced refactoring, allows you to make the code cleaner and simpler. If you think you've written clever code, then you've probably done something wrong. I’ve learned to take pride in writing simple, understandable, readable code.

2. What are some of the general guidelines you would follow when designing?

Design your code knowing that it WILL change. Along this idea, the other guidelines follow. You want to design code that helps the future you and your fellow colleagues. If it's impossible to make easy changes, you need to rethink how you approach your code.
	If requirements and/or code changes, don't we want to change as little as possible. Time is money. This directly leads to the Open Closed Principle. You should write code that is open to extension but closed to modification. Your original code structure should allow for new code to easily add to the current. But, we want to be able to do this without modifying current code. You want to be able to add functionality without breaking the current functionality. If you follow OCP, then further code changes can be efficient.
	Another principle that follows from the idea of "Time is money" aspect of software development is the Don't Repeat Yourself principle. Not only does repeating code waste time and money. It also allows for greater chance of bugs to creep in. Not only that, but it allows for bugs to actually surface more than once. The bug could be solved in one place but actually pop up again in the same code but a different location. 
	There are a few other principles that fall under the umbrella of creating simple, understandable, readable code. When you know that code will constantly and inevitably change, then you understand that code is not written primarily for the computer. Code is primarily written to be read by other developers. If you write code that is simple, clean, and very understandable, you save the company time and money because other developers can quickly understand and revise the code as necessary to evolve the design.
	Neatly under the umbrella of simple code, resides the You Aren't Gonna Need It and the Single Responsibility Principles. YAGNI (also with the Last Responsible Moment principles) teaches that you should delay the addition of complexity to when you actually need it. You don't want to write overly complex code and then realize that it's wasted or overkill for the situation. Similarly, Last Responsible Moment states that you should wait as long as possible to make irreversible architectural decisions. In both ideas, you should delay making decisions to when you have the most contextual information, and when it's completely necessary. 
	SRP also resides under creating simple code. To create simple and understandable code, units of code (functions, classes, modules) should do one narrow thing. Coupling two different ideas into one unit makes evolving code very difficult. SRP is closely tied to the idea of cohesion - the idea that the objects, functionality residing together should be together.
	To be able to continually and quickly evolve the code and maintain quality, one must use Test Driven Development with continuous integration. TDD allows you to move quickly with confidence that it still works. Not only that, but it actually molds your design. TDD forces cohesive and small functions and tests. TDD forces simplicity. TDD forces you to think like the user (could be real user or how other modules will interface). The tests themselves also become documentation. TDD also forces you to think about edge cases and thus forces you to make robust code. When you begin TDD, write the initial failing automated test case then produce a minimum amount of code to pass the test. This gives the confirmation on whether your code is behaving as expected or not and allows the design to evolve and adapt to changing needs.
	Another principle that allows for increased cohesion and reduced coupling is the Dependency Inversion Principle. High level modules should not depend on lower level modules but rather depend on abstractions. Also, the details should depend on the abstraction, not the other way around. DIP allows for implementations to vary regardless of the interface or external facing code. This reduced coupling is what allows for simpler evolution and extensibility of code.
	Another suggestion I have for software developers is that you should learn as much about design patterns as you can. One has to be careful and remember that design patterns should never be forced onto your code. Design patterns should reveal themselves organically while solving the problem. Knowing design patterns allows you to communicate clearly with other developers. Learning design patterns also allows you to come up with solutions without having to reinvent the wheel. Software development is all about using all the resources available to make good quality code.
	And finally, you and your organization should plan time to maintain previous code. You should plan to look back at previous code and see if it could be made simpler, cleaner, more readable, and more understandable. Essentially, code is not written, it's rewritten.

Total[10]: 10

