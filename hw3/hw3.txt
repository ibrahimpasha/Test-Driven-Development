HW3 Due 11:59PM October 11

According to the article <http://martinfowler.com/bliki/BeckDesignRules.html>, what are the rules of simple design. Why are these important? Discuss the impact of these principles. Give examples of using these principles in the class so far. Also, if you like, give from examples outside of this class, but limit to your personal experiences.

Martin Fowler summarized the four rules of a simple design of Extreme Programming given by Kent Beck as,

1. Passes the tests
Kent asserts that testing is the most vital first-class activity in software development which ensures software runs as it intended. Testing also has many other benefits. Writing tests influences the design of the code to include less coupling. One aspect of smelly code is functions and classes with many dependencies. Due to the difficulty of testing code with intricate dependencies, writing tests actually forces your code to be less coupled. Cohesion is usually seen as closely related to coupling and thus testing also influences your code to have more cohesion. In addition, testing also forces the programmer to think about the user (could be another piece of code or another programmer) of the piece of code form the beginning. It forces you to write usage-driven code rather than implementation-driven code. Writing tests also influences the robustness of your code by forcing you to systematically think about edge cases and how to address them. And finally, tests are a valuable piece of documentation. Looking at test cases gives you great insight into how the code behaves. 
In the previous homework, we learned that executing the test cases and ensuring that they successfully pass allows us to fully trust that it does what we expect. At times, we felt that even though not implementing the full logic of the program, writing successful test cases for the current code ensures that the code doesn't break and helped in moving further with confidence.

2. Reveals intention
According to Kent, communication is a core value of Extreme Programming and the way it's expressed by written code should reveal intentions behind the code in no time. He conveys that finding ways to make code understandable is a  5right thing to do because developer spend most of the time trying to understand their code. Having code that states why it exists helps in easy code navigation, understanding edge cases, debugging and bug fixing. Also, it benefits to produce maintainable, well-written and self documenting code. Programmers should be warned that this does not mean to flood the code with comments. Comments should be used sparingly because they tend to lie as code evolves. Also, comments can actually make the code less readable because you are not relying on the code to explain itself.
In Game of Life assignment, we used vague method names in initial design that lead to confusing program flow. After multiple reviews, we got to learn ways to give proper method names and shortening the method body by removing multiple assertions. We learnt that combining two or more program logic in one method lead us for confusion when debugging the error. Instead, we learnt to take out multiple functionalities from a single method and segregated them with proper names.

3. No duplication
Kent believes that eliminating redundancy is a powerful way to drive out good designs. He says everything should be said "Once and Only Once" which is sometimes expressed as the DRY(Don't Repeat Yourself) principle. The DRY principle has many benefits. If code is not repeated, then this ultimately leads to less code. Less code is good because it is easier to maintain. Less code makes it less likely for bugs to appear as well as easier to debug. And finally, less code makes the code more readable because there is less of it. In both of our projects, the aspect of no duplication showed itself in the simplicity of our code. We made sure to simplify down our code to where the functions had a single responsibility and no logic was repeated. 

4. Fewest elements
Kent addresses that anything that doesn't follow the above three rules has to be removed. Fowler summarizes this as adding extra future elements to the architecture generally makes the system harder to modify leading to an inflexible design. This rule was a major factor in both of our last designs. Minimizing programming artifacts benefits in improving cohesion so that similar things move close together and different things move farther apart. In the Game of Life assignment, we began with classes and methods. Eventually, we cut away unnecessary complexity and just simplified the design down to stand-alone functions rather than multiple classes with methods. This design decision carried over to the International Space Station assignment and also resulted in simple stand-alone functions. This simplicity allows for flexibility - other programmers can easily read and comprehend your program as well as modify it with ease.

The rules have been written generally in the order of their priority from high to low. The primary aim of code is to do what it is intended to do and that is why testing is the highest priority shown. Fowler says that the order of "no duplication" and "reveals intention" as unimportant since both rules feed off each other to refine the code. And if you come across a disagreement between the rules, you should follow the rule with a higher priority.


Total[10]: 10